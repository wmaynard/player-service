# player-service

An API for managing player inventory and stats.

This is a replacement for the Groovy player-service.  Please read about the important changes to the API in the [upgrade documentation](GROOVY_UPGRADE.md).

# Introduction

This service is the heavyweight and entry point for any game client.  Responsible for account management, player-service handles the important player data.  Something like chat-service can face downtime without much consequence, but if this service is down, the game itself is unplayable.

Consequently, any changes to player-service need to be carefully considered and thoroughly tested, with clear communication among all relevant team members.

# Glossary

| Term            | Definition                                                                                                                                                 |
|:----------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| AccountId / aid | The MongoDB identifier for an account.                                                                                                                     |
| Component       | A collection of related objects for the player.                                                                                                            |
| Discriminator   | A numeric value, 0-9999, appended to a screenname that guarantees a username is unique.                                                                    |
| Item            | An item can be a hero, piece of equipment, levelRunInfo, or autoplay data.                                                                                 |
| Link            | Connects one account to another.  When an account is **linked**, it reads and updates the data of a _different_ account rather than its own.               |
| Merge           | Outdated term.  The Groovy version of player-service used this to describe linking a new device SSO login to a previous account. The new term is **Link**. |
| Screenname      | The name a player has chosen.  For new accounts, this is generated by `NameGeneratorService` in an alliterative form of `{adjective} {noun}`.              |
| SSO             | Single Sign-On.  SSO refers to signing in with a third-party identity provider, such as Google Play, Apple ID, or Facebook.                                |
| Transfer        | Disconnects an SSO profile and attaches it to another.  This is effectively discarding account progress and starting anew.                                 |
| Username        | A user's full client-facing name, in the form of `Screenname#XXXX`.                                                                                        |

# environment.json

To run locally, all platform-services require an `environment.json` file in the top directory of the solution.  This includes the `PLATFORM_COMMON` value, which is shared across all services with later platform-common packages.

```
{
  "VERBOSE_LOGGING": false,
  "LOGGLY_URL": "https://logs-01.loggly.com/bulk/f91d5019-e31d-4955-812c-31891b64b8d9/tag/player-service-v2",
  "MONGODB_URI": "mongodb+srv://towerplayerserviceuser:{redacted}@tower-eng.zqdq2.mongodb.net/player-service-107?retryWrites=true&w=majority&minPoolSize=2",
  "RUMBLE_COMPONENT": "player-service",
  "RUMBLE_DEPLOYMENT": "wmaynard_local",
  "GOOGLE_CLIENT_ID": "5861154319-vcerqf8f392hj9q7dphljk1d70hdsm3l.apps.googleusercontent.com",
  "GOOGLE_APP_SECRET": "{redacted}",
  "GOOGLE_VALIDATE_TOKEN_URL": "https://www.googleapis.com/games/v1/applications/",
  "PLATFORM_COMMON": {
    "MONGODB_URI": {
      "*": "mongodb://localhost:27017/player-service-107?retryWrites=true&w=majority&minPoolSize=2"
    },
    "CONFIG_SERVICE_URL": {
      "*": "https://config-service.cdrentertainment.com/"
    },
    "GAME_GUKEY": {
      "*": "{redacted}"
    },
    "GRAPHITE": {
      "*": "graphite.rumblegames.com:2003"
    },
    "LOGGLY_BASE_URL": {
      "*": "https://logs-01.loggly.com/bulk/f91d5019-e31d-4955-812c-31891b64b8d9/tag/{0}/"
    },
    "RUMBLE_KEY": {
      "*": "{redacted}"
    },
    "RUMBLE_TOKEN_VALIDATION": {
      "*": "https://dev.nonprod.tower.cdrentertainment.com/token/validate"
    },
    "SLACK_ENDPOINT_POST_MESSAGE": {
      "*": "https://slack.com/api/chat.postMessage"
    },
    "SLACK_ENDPOINT_UPLOAD": {
      "*": "https://slack.com/api/files.upload"
    },
    "SLACK_ENDPOINT_USER_LIST": {
      "*": "https://slack.com/api/users.list"
    },
    "SLACK_LOG_BOT_TOKEN": {
      "*": "xoxb-4937491542-3072841079041-s1VFRHXYg7BFFGLqtH5ks5pp"
    },
    "SLACK_LOG_CHANNEL": {
      "*": "C031TKSGJ4T"
    },
    "SWARM_MODE": {
      "*": false
    },
    "VERBOSE_LOGGING": {
      "*": false
    },
    "RUMBLE_TOKEN_VERIFICATION": {
      "*": ""
    }
  }
}
```

# Class Overview

## Controllers
| Name              | Description                                                             |
|:------------------|:------------------------------------------------------------------------|
| `AdminController` | Handles the operations for administrative tools, such as the CS portal. |
| `TopController`   | Handles client requests to `launch`, `update`, etc.                     |

## Exceptions
| Name                                | Description                                                                                                                                                                                                |
|:------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `DiscriminatorUnavailableException` | Thrown when discriminator generation fails.  This should be a very rare occurrence and should only be possible if a large group of people actively creates thousands of accounts with the same screenname. |
| `InvalidUserException`              | A potential outcome of token generation.  Tokens require a non-null `aid`, `screenname`, and a `discriminator` greater than or equal to 0.                                                                 |
| `NameGenerationException`           | Thrown when the name generator can't create a name for a user.  Seeing this exception means the `NameGeneratorService` has exhausted its pool of adjectives or nouns and was unable to reload them.        |
| `SsoInvalidException`               | Thrown when an SSO provider can't authenticate one of their tokens.  The provider could be unavailable or the token could be invalid.                                                                      |
| `TokenGenerationException`          | Thrown when the token-service returned a null response or when token-service could not return a valid token.  If it's missing a token, the request was likely using invalid information.                   |

## Models
| Name                  | Description                                                                                                                                                                                                                                                                                                                                 |
|:----------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Component`           | A very simple model consisting of an `AccountId` and a `Data` field. Used to store data from the client in an agnostic way, without maintaining specific models.                                                                                                                                                                            |
| `DiscriminatorGroup`  | The base model for `DiscriminatorService`.  Each unique discriminator creates a group, and each group can have any number of members, so long as their screenname is unique.                                                                                                                                                                |
| `DiscriminatorMember` | Represents a player account within the context of the `DiscriminatorService`.  Tracks the AccountId and Screenname for a user.                                                                                                                                                                                                              |
| `Item`                | Items are similar to components in that they're a minimalistic model used to store whatever data the client needs in an agnostic manner.  The difference is that every item is stored as a separate document in the collection, for better or for worse, as this does add challenge when manually looking into issues.                      |
| `Player`              | Represents a player account.  Contains information about the local client installation, data versions, and any relevant transfer tokens.                                                                                                                                                                                                    |
| `Profile`             | Represents an SSO account.  Used to identify an account when a client is logging in with external services such as Google Play.                                                                                                                                                                                                             |
| `SsoData`             | This model contains information that's returned by SSO providers, which may or may not include personally identifiable information (PII) such as email address, given names, family name, and profile photo information.  SSO providers don't necessarily provide us with the same information as their competitors, so fields may be null. |

Notes: 

1. Generally speaking, don't use `Player.Id` when looking for data.  Use `Player.AccountId`.  This is a wrapper that first checks to see if the `Id` has been overridden.
2. While there are profiles for `installIds`, these are possibly unnecessary with the changes to the way accounts are linked to their data.  For more information, see the [upgrade documentation](GROOVY_UPGRADE.md).

### Models.Responses
| Name             | Description |
|:-----------------|:------------|
| `LaunchResponse` |             |

## Services
| Name                   | Description                                                                                                                                   |
|:-----------------------|:----------------------------------------------------------------------------------------------------------------------------------------------|
| `DiscriminatorService` | Generates **discriminators** for users.  When a username changes, it attempts to use the one previously assigned before generating a new one. |
| `ItemService`          | Stores, updates, and retrieves **items** for a player.  **Items** are very loosely defined and act as generic stores of objects for the game. |
| `NameGeneratorService` | Generates an alliterative name for new players in the form of `{adjective} {noun}`.                                                           |
| `PlayerAccountService` | Retrieves and updates information for client installations.                                                                                   |
| `ProfileService`       | Retrieves and updates information for SSO logins.                                                                                             |

Notes:

1. The source pool for the `NameGeneratorService` is split between `~/adjectives.txt` and `~/nouns.txt`.  Every word in the pool should be its own line.  Words can be commented out with `//`.

### Services.ComponentServices

| Name                 | Description                                                         |
|:---------------------|:--------------------------------------------------------------------|
| `AbTestService`      |                                                                     |
| `AccountService`     |                                                                     |
| `ComponentService`   | Base class for all component services.                              |
| `EquipmentService`   ||
| `HeroService`        ||
| `MultiplayerService` ||
| `QuestService`       ||
| `StoreService`       ||
| `SummaryService`     | Stores information such as hero score for PvP / social information. |
| `TutorialService`    ||
| `WalletService`      ||
| `WorldService`       ||

### Regarding the efficacy and design of components and items

Will on 2021.12.16:

.NET Platform standards are to have a separate Service for every collection in MongoDB.  Conceptually, this is simple and intuitive.  Unfortunately, the way the groovy solution was architected, data was spread out over nearly a dozen collections.  While we could make an exception and create one Service to handle multiple collections, I'd much rather remain consistent with our current standards.

The original design strikes me as questionable.  I suspect it was coming from someone with an RDBMS background, thinking that this would be more efficient because each collection is like a 
table.  This means that to fully update a player record, we're running a dozen updates instead of just one.  Consequently, there are many more possible points of failure and we're much more likely to require a transactional rollback when updating more than one component at a time.  It's also much more work to maintain.

We aren't really at risk of hitting the maximum document size of 16MB.  I suspect there's an opportunity to both increase performance and reduce complexity by moving everything to something like a `Record` with fields for each component, and only have one per player account.  Alternatively, having a `components` collection that relies on a `type` or `name` filter at least would allow us to bundle everything into one neat query - either for retrieval or storage.

Similarly, the `items` collection is iffy.  As designed, every single item is stored as a separate entry in MongoDB.  Each hero, each piece of equipment, each autoplay... all of these are separate entries.  At the time of this writing, there are over 2.3m records in prod.  I've been unable to find a definitive answer, but I suspect there is a point where the number of documents impacts performance.

## Utilities
| Name          | Description                                                                                                                |
|:--------------|:---------------------------------------------------------------------------------------------------------------------------|
| `AppleToken`  | Apple ID requires decrypting a token and validating it via a provided public key.  This utility handles the related logic. |

## Endpoints

### Top level

| Method | Endpoint      | Description                                                                                                                        | Required Fields | Optional Fields |
|-------:|:--------------|:-----------------------------------------------------------------------------------------------------------------------------------|:----------------|:----------------|
|    GET | `/config`     | Returns dynamic config variables for the client.                                                                                   |||
|    GET | `/health`     | Health check; returns the status of all services.                                                                                  |||
|    GET | `/lookup`     | Retrieves information about comma-separated accountIds for UI purposes.  Information should be cached on the frontend.             | `accountIds`    ||
|  PATCH | `/screenname` | Changes the user's screenname.  Returns an updated token that must be used to reflect changes in platform services (such as chat). | `screenname`    ||
|  PATCH | `/update`     | Updates a player record (components, items).                                                                                       | `components`    ||

### Login

See [LOGIN.md](LOGIN.md) for detailed information on `/account/` endpoints.

### Admin

| Method | Endpoint    | Description                                                                                                                       | Required Fields | Optional Fields |
|-------:|:------------|:----------------------------------------------------------------------------------------------------------------------------------|:----------------|:----------------|

## Example Flow

![alt text](player-service-v2.png?)

## Future Updates, Optimizations, and Nice-to-Haves

Items have proven to be a huge bottleneck for this service.  From an initial investigation, it seems that it's impossible to pass data between consumers of services and MongoDB without de/serializing the JSON.  For small documents, this is a negligible cost.  However, particularly for the **autoplay** data, this causes the service to become compute-bound, taking upwards of 5 seconds even when the deployed service has unlimited CPU allocation.  This was not an issue with the Java driver for Mongo DB - Groovy was able to pass data along without knowing what it was; no Model as a contract and weak typing made for a painless transfer.  The problem isn't the size of the data - which in worst cases is currently 1.3 MB - but rather the number of properties that need to be converted.

The best solution is to pass any large datasets into a flatbuffer and subsequently encoded as a base64 string.  This allows player-service to accept a compressed string for a data object rather than iterating over the data's various and deeply-nested properties.

## Troubleshooting

_/player/launch is failing!_

This is an environment variable or dynamic config issue.  The service requires the dynamic config value `playerServiceToken` in order to generate new tokens for users.  This cannot be copied from another environment; tokens must be generated explicitly for their environments by design.  Double check that this value is present, and verify that it's valid by making a request to `/token/validate` using the token.

If launch is still failing, verify that token-service is running and environment variables are all set correctly for both services.

It's also possible that a particular account has been banned by token-service - this is new functionality that previously was unavailable.  Bans apply to account ids and cause token generation to fail when requested.